---
title: Tetris as an EFI application
---

Ever turn on a computer and wish you could just boot right in to Tetris?
No?
Well, in case the urge ever did strike you, it's now a solved problem!
Provided, of course, that your computer runs UEFI.

UEFI is a specification for a software layer between an operating system and a
computer's firmware. It essentially replaces the BIOS, which is great because
BIOS was never really formally specified. This comes with numerous
disadvantages, the most important one being that you can't quite be *sure* what
services a particular motherboard's BIOS will provide.
UEFI on the other hand mandates the presence of many services and provides a
mechanism for performing service discovery.
For example, UEFI provides a way to access a framebuffer on the computer's
monitor, to generate random numbers, to set and wait for timers, and to read
input peripherals such as a keyboard and mouse. And these are precisely the
ingredients necessary to bake a Tetris cake.

I'll show you in this article how I compile EFI applications using the
gnu-efi library, access the framebuffer and keyboard, and generate random
numbers, all by using UEFI services.

Requirements
------------

I use Linux as my development platform, so the instructions will be specific to
Linux.

To compile EFI applications, you'll need the `gnu-efi` library, and the
following programs:
- `objcopy`
- `clang`
- `ld`

To run them, you'll need the following programs:
- `sfdisk`
- `mkfs.fat`
- `dd`
- `qemu-system-x86_64` and the OVMF firmware

Compiling EFI applications
--------------------------

The UEFI specification requires that EFI applications be stored in the Portable
Executable (PE) format. This makes compiling EFI applications on Linux somewhat
more difficult since Linux uses ELF files for executables, so this is the
default output format for compilers.
Although in principle it's possible to build a cross-compiler to generate a PE
file directly containing the EFI application, I found it easier to generate an
ELF shared object file and convert it to PE using `objdump`.
There's one additional consideration when using this approach: although an ELF
file is being generated, the generated machine code needs to use the MS ABI
instead of the Linux ABI. The ABI defines what registers are used in what order
when calling functions, and the UEFI spec requires the Microsoft way of doing
things.

Here's an adapted except of the Makefile I use for compiling a hello world program.
You may need to adjust some paths to suit your Linux distribution.
```
CC=clang
EFI_INCLUDES=\
    -I/usr/include/efi \
    -I/usr/include/efi/protocol \
    -I/usr/include/efi/x86_64

EFI_CFLAGS=\
    -Wall \
    -Werror \
    -ffreestanding \
    -fno-stack-protector \
    -fpic \
    -DHAVE_USE_MS_ABI \
    -fshort-wchar \
    -mno-red-zone \
    $(EFI_INCLUDES)
    
EFI_CRT_OBJ=/usr/lib/crt0-efi-x86_64.o
EFI_LDS=/usr/lib/elf_x86_64_efi.lds

EFI_LDFLAGS=\
    -nostdlib \
    -znocombreloc \
    -T $(EFI_LDS) \
    -shared \
    -Bsymbolic \
    -L/usr/lib
    
.PHONY: all
all: hello.efi

# Use objcopy to convert the ELF file to PE format.
%.efi: %.so
    objcopy -j .text -j .sdata -j .data \
    -j .dynamic -j .dynsym  -j .rel \
    -j .rela -j .reloc -j .eh_frame \
    --target=efi-app-x86_64 $^ $@
    
hello.so: main.o
    $(LD) -o $@ $(EFI_CRT_OBJ) $^ $(EFI_LDFLAGS) -lefi -lgnuefi
    
%.o: %.c
    $(CC) $(EFI_CFLAGS) -c -o $@ $^
```

When adding a new `.c` file to the project, I add a corresponding `.o` entry to
the dependencies of `hello.so`, so it gets compiled and linked into the final
application. Sadly this Makefile doesn't detect changes to header files; this
could be added by using the compiler's dependency analysis features, but I can't
be bothered to figure that out just get.

Hello world
-----------

So what goes in `main.c`? Fairly normal looking C code, to be honest!
The UEFI firmware that launches our application has already put the processor in
protected mode, and on 64-bit platforms has already switched the processor into
long mode, with an identity page mapping. (To my understanding, this means
virtual addresses coincide with physical addresses in memory.)
The upshot is that we don't need to write assembly code to do this processor
mode switching ourselves.

When launched by the UEFI firmware, our application is in a pre-boot stage
in which numerous "boot services" are available. To work, these services use up
a (minimal) amount of the computer's memory and CPU resources. In a realistic
OS, these services can be disabled and their resources reclaimed by calling
`EFI_BOOT_SERVICES.ExitBootServices()`, after which full control of the platform
is given to the EFI application, so that it may for example launch an OS kernel.

Even after boot services have been exited, the UEFI firmware provides a few
_runtime services_. Broadly speaking, these allow access to the computer's
clock, to EFI variables, and to reboot the computer. Nothing particularly
advanced. I don't call `ExitBootServices()`, since all the services needed to
implement Tetris wouldn't be available anymore.

Enough talk. Let's see hello world already!

```
#include <efi.h>
#include <efilib.h>

EFI_STATUS efi_main(EFI_HANDLE image_handle, EFI_SYSTEM_TABLE *system_table) {
    InitializeLib(image_handle, system_table);
    Print(L"Hello world!\n");
    return EFI_SUCCESS;
}
```

Surprisingly simple! Instead of the standard library (which isn't available), we
include the EFI headers. 


