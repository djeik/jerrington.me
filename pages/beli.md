---
title: Beluga Interactive Mode
---

### Bugs

* Holes are not allowed on the LF level.

  It should be possible to see a list of candidates and choose one, or use the
  logic programming engine to fill it.
  Lots of commands don't make sense on the LF level, like splitting.

* Holes are not allowed in `let` declarations; only in `rec` declarations.

  That's because the type annotation is not considered! Let has to be
  *synthesizable*, not *checkable*.

* Executing a split command with no file loaded results in an unhandled
  exception.

  More generally, I think each command should "just work", without the user
  knowing which commands it depends on.
  So the elisp code for split should:
    - save the current buffer to disk;
    - `%:load` the current buffer into Beli;
    - highlight the holes;
    - finally, call `%:split`.

* Hole overlay is incorrectly positioned

  Upshot: the text under the _overlay_ is deleted and replaced when an
  interactive mode command is executed, e.g. `%: split 0 s` will remove the
  space right before hole 0.

  steps to replicate:

  - open [arithmetic-bug-1.bel][1].
  - run `:beli` to start the Beluga interactive mode.
  - run `:beluga-highlight-holes`.

  [Result](https://files.jerrington.me/arithmetic-bug-1.png).

  In `beluga-mode.el`, there is an alternative implementation of `beluga--pos`
  commented out that is "more efficient".
  However, it gives even worse results: it's totally off for both the line and
  column. But intuitively, this algorithm should really just work: it simply
  moves the cursor to the beginning of the file, and then moves it according to
  the `offset` given by Beluga.

  This suggests to me that the bug lies within the Beluga parser itself.
  
  Update (2018-02-01): After speaking with David and messing around some more,
  we discovered that the "more efficient" algorithm is off by the *number of
  lines*. It appears that line terminators are not counted when calculating the
  offset. We can correct for this in the elisp code by adding the line number of
  the hole to its offset within the file, but the real solution is to fix the
  parser.

  Update (2018-02-01): problem might be in `skip_newlines` in `lexer.ml`;
  there's no `Loc.shift`.

  Update: messing around with inserting `Loc.shift` seems to make things
  worse. In particular, line numbers are incorrect.

  Update (2018-02-20): further messing around with `Loc.shift` in the lexer
  seems to make things better. I don't understand why it's behaving now. Now, no
  matter where the hole is in the file, the reported location is only off by
  two. There are situations where it can be off by more, and these arise due to
  the numerous different places where newlines are handled inside the lexer. For
  example, comments have their own newline handling, so inserting comments
  affects the reported hole location.

  Update (2018-02-21): I built a tool to "see what Beluga sees" by dumping the
  token stream constructed by lexing a source file. This tool is now checked in
  to my copy of Beluga, and is called `lex_dump`.

  What I saw amazed me.

  It turns out that all token locations in the sample file I used were
  completely wrong: every token supposedly had a length of 1, and was off by
  one. Strangely, the very first token had a length of zero, and was assigned
  the character span of `0-0`. Notice that this is exactly the character span
  generated by the initial location used to kick-start the lexer. The very first
  call to `Loc.shift` would change this to the span `0-3` by making the new
  start offset the old stop offset and moving the stop offset by the number of
  characters in the lexeme, which in my sample file was `rec`. This suggested to
  me that each token was being assigned the Loc of the *preceding* token. That
  explains the 1-length tokens: those are the spaces between the words in the
  file!

  The bug came from `lexer.ml`, specifically the expression:

  ```
  let tok = Some (lex_token loc_ref lexbuf, !loc_ref) in
  ```

  `lex_token` has side effects: in particular it updates `loc_ref` to refer to
  the right place for the lexeme that is being currently processed. An old
  version of OCaml [supposedly evaluates arguments left-to-right][ocaml-lies],
  but it is said that we should not depend on this. In fact, my OCaml evaluates
  from right to left, which is the only explanation for this behaviour!
  The OCaml specification specifically [leaves unspecified][ocaml-truths] the
  evaluation order for products (and for functions), yet this code in Beluga
  *depended* on a particular evaluation order.
  *Sigh.*

### Interactive mode features we should have

* Holes can be named, e.g. `?foo`

  This way, we can use a command like `%: split foo s` to introduce a
  split on variable `s` at the hole named `foo`.
  The user no longer needs to "just know" what the number of all the holes are.

  Anonymous holes `?` can still be supported, and would be implicitly numbered
  as they currently are.
  There is a question about what should happen if a user names a hole with a
  number, e.g. `?0`. A simple solution is to disallow such names by users:
  hole names should be valid identifiers, and identifiers cannot begin with
  numbers.

  When interactive commands generate new holes (e.g. as the result of a split),
  these new holes should also be given names, even if they're simple names like
  `a1`, `a2`, etc. This way the user can see in the file what the hole number
  is.

* Commands automatically start the interactive mode

  (This is low-hanging fruit.)

  The user needs to manually run `:beli` to start the interactive mode.
  Instead, we can add a check to each command to start the interactive mode.
  
  More generally, each interactive mode command should run all the commands it
  depends on, if any, such as saving the buffer to disk, loading it into Beli,
  running `beluga-highlight-holes`, etc.

* Split command detects whether there is a hole at the point, and if any,
  avoids prompting for the hole to split on.

### Confusion

* What's a "line directive" (Camlp4)? Comments in `beluga-mode.el` suggest that
  the `bol` (beginning-of-line) and `offset` values returned by Beluga (and
  ultimately coming from from Camlp4) might not be correct due to these
  directives.
  Would these directives be written into a Beluga source file? Why would
  someone use them?

[1]: https://files.jerrington.me/arithmetic-bug-1.bel
[ocaml-lies]: https://caml.inria.fr/pub/docs/oreilly-book/html/book-ora029.html
[ocaml-truths]: https://caml.inria.fr/pub/docs/manual-ocaml/expr.html#sec144
